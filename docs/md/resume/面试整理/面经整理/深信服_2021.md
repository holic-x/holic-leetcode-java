# 深信服

[TOC]



## 1.深信服面经参考

​	<font color=red>面经参考牛客网大神们的经历，结合自身理解梳理相关的答案</font>

### <1>参考1

#### 二面面经

##### 1>SpringBoot跟Spring的关系（衍生框架对比说明）

​	Spring框架为开发Java应用程序提供了全面的架构支持，其主要包括IOC、DI、AOP等内容

```properties
Spring JDBC：对JDBC的简单封装
Spring MVC：Spring MVC框架的实现
Spring Security：安全管理框架
Spring AOP：面向切面编程
Spring ORM：对象关系映射，集成orm框架（Mybatis，Hibernate）
Spring Test：Spring测试，提供junit 和 mock测试功能
```

​	Spring Boot是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，使开发部署更加方便



##### 2>SpringBoot的自动装配原理 

```java
@SpringBootApplication
public class TestApplication{
    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
```

​	springBoot启动类是一个main方法，main方法是java程序的入口，通过上述参考代码调用run方法，一步步跟踪代码，直到一个run方法中有`refreshContext(context)`方法（读取配置、扫描注解）

> @SpringBootApplication注解中有三个重要的注解：

@SpringBootConfiguration：用来标注一个类为配置类的（相当于Spring的@Configuration）
@ComponentScan：用来将指定包下面需要装配的组件注册到容器里面去
@EnableAutoConfiguration：springBoot的自动配置的核心注解，用于开启的springBoot的自动配置

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
		...
}
```

​	EnableAutoConfiguration中引入了一个类`AutoConfigurationImportSelector`，该类会有一个核心方法实现从类路径下的meta-info/spring.factories下加载配置文件、类等到容器中，这些配置类里面有许多条件注解，它会根据引入的jar包、注入的bean来自动将相关的bean注入到容器中，从而实现了自动装配

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```



##### 3>对象的比较有哪几种方式 

​	对象的比较一般有3种方式：关于对象值的比较（==/equals）、关于对象值大于、等于、小于的比较（基于自然顺序）：Comparable、关于对象值大于、等于、小于的比较（基于比较器）：Comparator

​	Object.equals 因为所有类都是继承自Object的，所以直接覆写即可，不过只能比较相等与否

​	Comparable.compareTo需手动实现接口，侵入性比较强，但一旦实现，每次用该类都有顺序，属于内部顺序

​	Comparator.compare需要实现一个比较器对象，对待比较类的入侵性弱，但对算法代码实现入侵性强

> <font color=red>关于对象值相等的比较</font>
>
> a.== / equals
>
> b.重写equals方法

​	`p == q`：判断p和q两个引用是否指向同一个对象

​	`p.equals(q)`：判断字符串值是否相同，或判断p指向的对象和q指向的对象的内容是否一一相等的（可自定义比较目标）

```java
public class Card{
	public int rank;
	public String suit;
  public Card(int rank,String suit){
		this.rank = rank;
		this.suit = suit;
  }
}

// 比较说明
Card p = new Card(1,"♠");
Card q = new Card(1,"♠");
Card o = p;
p == o;//true
p == q;//false
p.equals(o);//true 因为如果不覆写equals，此处对象默认的equals逻辑就是引用比较
p.equals(q);//false 因为如果不覆写equals，此处对象默认的equals逻辑就是引用比较
```

​	重写equals方法

```java
public class Card{
	public int rank;
	public String suit;
  public Card(int rank,String suit){
		this.rank = rank;
		this.suit = suit;
  }
  @Override
  public boolean equals(Object o){
		if (this == 0){
			return true;
		}
    if (o == null || instanceof Card){
      return false;
    }       
		Card c = (Card)o;
		return rank == c.rank&&suit.equals(suit);
	}
}

// 比较说明
Card p = new Card(1,"♠");
Card q = new Card(1,"♠");
Card o = p;
p == o;//true
p == q;//false
p.equals(o);//true 
p.equals(q);//true (重写了euqals方法，按照自定义规则进行比较)
```



> <font color=red>关于对象值大于、等于、小于的比较（基于自然顺序）：Comparable</font>

```java
public interface Comparable<E>{
	//返回值
	//<0：表示 this 指向的对象小于o指向的对象
  //==0：表示 this 指向的对象等于o指向的对象
	//>0：表示 this 指向的对象大于o指向的对象
	int compareTo(E o);
}
```

```java
public class Card implements Comparable<Card>{
        public int rank; //数值
        public String suit; //花色

        public Card(int rank,String suit){
            this.rank = rank;
            this.suit = suit;
        }
        @Override
        public int compareTo(Card o){
            if (o == null){
                return 1;
            }
            return rank - o.rank;
        }
    }

    Card p = new Card(1,"♠");
    Card q = new Card(2,"♠");
    Card o = new Card(1,"♠");
    
    p.compareTo(o);// ==0表示牌相等
    p.compareTo(q);//<0 表示p比较小
    q.compareTo(p);//>0表示q比较大
```



> <font color=red>关于对象值大于、等于、小于的比较（基于比较器）：Comparator</font>

```java
public interface  Comparator<T>{
	//返回值
	//<0:表示o1指向的对象小于o2指向的对象
	//==0:表示o1指向的对象等于o2指向的对象
	//>0:表示o1指向的对象大于o2指向的对象
	int compare(T o1,T o2);
}
```

```java
public class Card implements Comparable<Card>{
        public int rank; //数值
        public String suit; //花色

        public Card(int rank,String suit){
            this.rank = rank;
            this.suit = suit;
        }
        public class CardComparator implements Comparable<Card>{
            @Override
            public int compare(T o1, T o2){
                if (o1 == o2){
                    return 0;
                }
                if (o1 == null){
                    return -1;
                }
                if (o2 == null){
                    return 1;
                }
                return o1.rank - o2.rank;
            }
        }
    }

    Card p = new Card(1,"♠");
    Card q = new Card(2,"♠");
    Card o = new Card(1,"♠");

    cmptor.compare(p,o);// ==0表示牌相等
    cmptor.compareTo(p,q);//<0 表示p比较小
    cmptor.compareTo(q,p);//>0表示q比较大
```



##### 5>hashcode方法的作用

​	<font color=blue>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值</font>

​	其主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括<font color=red>HashSet、HashMap以及HashTable</font>。当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。从而解决了向含有大量数据的集合中添加元素时，大量频繁的操作equals方法的问题

​	通常来说，<font color=red>一个类的两个实例对象用equal方法比较的结果相等时，其哈希码也必须相等，但反之则不成立</font>。即equals方法比较结果不相等的对象可以有相同的哈希码，或者说哈希码相同的两个对象的equal方法比较的结果可以不等

​	当一个对象被存储进hashset集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进hashset集合时的哈希值就不同了，这种情况下，即使在contains方法使用该对象的当前引用作为的参数去hashset集合中检索对象，也将返回找不到对象的结果，这也会导致无法从hashset集合中单独删除当前对象，从而造成内存泄露，所谓的内存泄露也就说有一个对象不再被使用，但它一直占有内存空间，没有被释放



##### 6>HashMap：put方法的流程（源码分析）

​	JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK8中采用的是位桶+链表/红黑树

​	HashMap在put方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。如果索引处为空，则直接插入到对应的数组中，否则，判断是否是红黑树，若是，则红黑树插入，否则遍历链表，若长度不小于8，则将链表转为红黑树，转成功之后 再插入



##### 7>线程安全在java中的实现方式

​	<font color=red>实现线程安全的方式：同步代码块、同步方法、锁机制</font>

​	一个程序在运行起来的时候会转换成进程，通常含有多个线程。

​	通常情况下，一个进程中的比较耗时的操作（如长循环、文件上传下载、网络资源获取等），往往会采用多线程来解决。比如显示生活中，银行取钱问题、火车票多个售票窗口的问题，通常会涉及到并发的问题，从而需要多线程的技术。当进程中有多个并发线程进入一个重要数据的代码块时，在修改数据的过程中，很有可能引发线程安全问题，从而造成数据异常。例如，正常逻辑下，同一个编号的火车票只能售出一次，却由于线程安全问题而被多次售出，从而引起实际业务异常。

> 售票问题分析：在不对多线程数据进行保护的情况下会引发的状况

```java
public class ThreadUnSecurity {
    static int tickets = 10;
    class SellTickets implements Runnable{
        @Override
        public void run() {
            // 未加同步时产生脏数据
            while(tickets > 0) {
                System.out.println(Thread.currentThread().getName()+"--->售出第：  "+tickets+" 票");
                tickets--;
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (tickets <= 0) {
                System.out.println(Thread.currentThread().getName()+"--->售票结束！");
            }
        }
    }
    
    
    public static void main(String[] args) {
        SellTickets sell = new ThreadUnSecurity().new SellTickets();
        
        Thread thread1 = new Thread(sell, "1号窗口");
        Thread thread2 = new Thread(sell, "2号窗口");
        Thread thread3 = new Thread(sell, "3号窗口");
        Thread thread4 = new Thread(sell, "4号窗口");
        
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
    }
}
```

​	<font color=red>运行结果：同一张票在不对票数进行保护时会出现同一张票会被出售多次！由于线程调度中的不确定性，在演示上述代码时，出现的运行结果会有不同。</font>

> <font color=blue>解决方案1：同步代码块</font>

```java
import com.sun.org.apache.regexp.internal.recompile;
public class ThreadSynchronizedSecurity {
    static int tickets = 10;  
    class SellTickets implements Runnable{

        @Override
        public void run() {
            // 同步代码块
            while(tickets > 0) {
                
                synchronized (this) {
                    
//                    System.out.println(this.getClass().getName().toString());
                    
                    if (tickets <= 0) {
                        
                        return;
                    }
                    
                    System.out.println(Thread.currentThread().getName()+"--->售出第：  "+tickets+" 票");
                    tickets--;
                    
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                
                if (tickets <= 0) {
                    
                    System.out.println(Thread.currentThread().getName()+"--->售票结束！");
                }
            }
        }
    }   

}
```

> <font color=blue>解决方案2：同步方法</font>

```java
public class ThreadSynchroniazedMethodSecurity {  
    static int tickets = 10;  
    class SellTickets implements Runnable{
        @Override
        public void run() {
            //同步方法
            while (tickets > 0) {
                
                synMethod();
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                
                if (tickets<=0) {
                    
                    System.out.println(Thread.currentThread().getName()+"--->售票结束");
                }   
            }
        }
        
        synchronized void synMethod() {
            
            synchronized (this) {
                if (tickets <=0) {
                    
                    return;
                }
                
                System.out.println(Thread.currentThread().getName()+"---->售出第 "+tickets+" 票 ");
                tickets-- ;
            }   
        }   
    }
}
```

> <font color=blue>解决方案1：同步代码块</font>

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadLockSecurity {    
    static int tickets = 10;
    class SellTickets implements Runnable{ 
        Lock lock = new ReentrantLock();
        @Override
        public void run() {
            // Lock锁机制
            while(tickets > 0) {
                try {
                    lock.lock();
                    if (tickets <= 0) {
                        return;
                    }
                    System.out.println(Thread.currentThread().getName()+"--->售出第：  "+tickets+" 票");
                    tickets--;
                } catch (Exception e1) {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
                }finally {
                    lock.unlock();
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
                
            if (tickets <= 0) {
                System.out.println(Thread.currentThread().getName()+"--->售票结束！");
            }
        }
    }
}
```

​	由于synchronized是在JVM层面实现的，因此系统可以监控锁的释放与否；而ReentrantLock是使用代码实现的，系统无法自动释放锁，需要在代码中的finally子句中显式释放锁lock.unlock()。

​	另外，在并发量比较小的情况下，使用synchronized是个不错的选择；但是在并发量比较高的情况下，其性能下降会很严重，此时ReentrantLock是个不错的方案。　

​	在使用synchronized 代码块时,可以与wait()、notify()、nitifyAll()一起使用，从而进一步实现线程的通信。其中，wait()方法会释放占有的对象锁，当前线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序；线程的sleep()方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁，也就是说，在休眠期间，其他线程依然无法进入被同步保护的代码内部，当前线程休眠结束时，会重新获得cpu执行权,从而执行被同步保护的代码。
​	wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。

​	notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM会在等待的线程中调度一个线程去获得对象锁，执行代码。

​	需要注意的是，wait()和notify()必须在synchronized代码块中调用。notifyAll()是唤醒所有等待的线程。



##### 8> 说说volatile 

参考链接：https://www.techug.com/post/java-volatile-keyword.html

a.保证了不同线程对该变量操作的内存可见性;

b.禁止指令重排序

应用场景：

a.状态量标记，就如上面对flag的标记

b.单例模式的实现，典型的双重检查锁定（DCL）





##### 9>一次完整的 HTTP 请求所经历的步骤，用到了那些协议，具体说一下 

​	HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

> 1.建立TCP连接

​	在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

> 2.Web浏览器向Web服务器发送请求命令

一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。

> 3.Web浏览器发送请求头信息

浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

> 4.Web服务器应答

客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

> 5.Web服务器发送应答头信息

​	正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

> 6.Web服务器向浏览器发送数据

​	Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

> 7.Web服务器关闭TCP连接

​	一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive

​	TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。



##### 10>日常项目中如何进行sql调优的，场景分析

> 程序设计方面：数据库设计、索引设计

<font color=red>结合实际需求和功能记性数据表设计，分库分表概念（结合实际场景应用进行说明）</font>

​	例如在设计“孵化云贷线上测额系统”的时候，考虑不同测额模式的扩展，将企业的测额信息拆分为多个表进行关联存储：创建主表fhyd_ep_info、关联fhyd_white_list、fhyd_channel、fhyd_other表等，在主表中通过ce_mode和指定测额模式关联的字段关联从表数据，从而实现相应的扩展，冗余部分字段也便于后续项目迭代。

​	在流程设计上，参考flowable流程引擎的设计概念，将业务流程处理和业务数据进行拆分，创建流程表和关联业务数据表、操作日志等相关，考虑数据量大的问题还可通过将当前流程和历史流程数据进行拆分（有些按时间维度拆分表）



<font color=red>给表适当添加索引，注意索引失效的场景</font>



> SQL调优：操作优化、查询优化

​	<font color=red>EXPLAIN 可以查看SQL的执行计划，从中获取SQL优化的提示，常见的客户端工具如PL/SQL Developer、Navicat、Toad都支持查看解释计划</font>

```sql
explain plan for [SQL]
```

​	一次查询数据量过大可拆分多次查询，或者降低数据量

​	针对一些特定的应用场景可通过缓存的方式实现，例如程序初始化的时候加载数据随后定时更新缓存

​	可能是由于sql执行出现了锁或者死锁的情况（程序设计的缺陷：此前曾尝试过设定触发器和数据修改操作出现冲突导致锁表，执行效率低下）

​	查询语句编写没有注意规范，需要结合相关的参考进行sql优化（select *操作需替换为指定列查询、left join可用子查询替代）

​	<font color=red>结合业务场景进行SQL设计，数据库设计是程序构建的基础</font>


##### 11>联合索引a，b，where a>5 and b=5, 索引会失效吗？ （引申索引失效的场景）

​	<font color=red>联合索引（复合索引）必须要按照顺序使用（a,ab,abc,ac），如果中间出现了断点（范围值等）会阻塞后面的索引，导致索引失效</font>



###### 索引失效的场景说明

> like这种就是%在前面的不走索引，在后面的走索引
>
> （A走索引，B不走索引）

```sql
A:select * from student where 'name' like '王%'
B:select * from student where 'name' like '%小'
```



>用索引列进行计算（计算、函数、（自动or手动）类型转换）会导致索引失效而转向全表扫描
>
>（A走索引，B不走索引）

```sql
A:select * from student where age = 10+8
A:select * from student where  concat('name','哈') ='王哈哈';

B:select * from student where age + 8 = 18
B:select * from student where name = concat('王哈','哈');
```



> 索引列用了!= ，或者是索引字段进行判空查询时（对索引字段判断是否为NULL），不走索引

```sql
select * from student where age != 18
```



> 在where子句中使用`or`来连接条件时，如果俩个字段中有一个没有索引，引擎会放弃索引而产生全表扫描

```sql
SELECT id FROM table WHERE num = 0 OR num = 1
```



> 随着表的增长，where条件出来的数据太多，大于15%，使得索引失效
>
> 字符串不加单引号，索引失效







##### 12>平时用的是哪种事务隔离机制，简单说说原理（确认数据库层面还是Spring？）

​	数据库层面：Oracle支持两种隔离级别 `read_commited` 、`Serializable`,默认的隔离级别是`read_commited`

​	

​	Spring框架采用：结合Spring传播行为分析

​	Spring在TransactionDefinition接口中定义了一下五个不同的事务隔离级别：

​	`ISOLATION_DEFAULT`：这是一个PlatformTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别

​	`ISOLATION_READ_UNCOMMITTED`： 这是事务最低的一个隔离级别。它表示允许事务2访问到事务1未提交的数据，所以，这种隔离级别会产生脏读、幻读、不可重复读

​	`ISOLATION_READ_COMMITTED`： 保证了事务1修改后的数据提交后才能被事务2读取，未提交的数据不能被其他事务读取。这就避免了脏读，但不可避免幻读和不可重复读

​	`ISOLATION_REPEATABLE_READ`： 既保证了一个事务未提交的已修改数据不能被其他事务读取，也保证了不会发生不可重复读，但不能避免幻读

​	`ISOLATION_SERIALIZABLE`： 花费代价最高但是最可靠的一种事务隔离级别。事务被处理为顺序执行，避免了幻读、不可重复读、脏读



##### 13>jvm基本概念，jvm内存划分说一下 



##### 14>jvm堆的分代思想说一下 



##### 15>大对象的分配流程说一下 



##### 16>多线程应用？

   线程池原理？应用？自定义线程池？参数设置参考？



##### 17>Lock包下的类有了解吗？说说你经常使用的一些并发类库 



##### 18>Redis缓存穿透、缓存击穿、缓存雪崩了解吗？详细说说，并给出解决方案 



##### 19>Redis的基本数据类型 

string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)



#### Netty相关

##### 20>Netty了解吗，为什么高性能 ？

##### 21>Netty零拷贝了解吗？ 

##### 22>Netty可以自定义序列化机制吗？有自己实现过自定义的序列化机制吗 ?

##### 23>有自己实现过chandlehandler吗？有自己去处理过一些数据包吗?

### <2>参考2

#### 二面面经

##### 1>hashcode和equals方法的关系





##### 2>有没有可能 2 个不相等的对象有相同的 hashCode？

​	可能存在，但在存储上可能会有冲突



##### 3>解决哈希冲突的方法有哪些？

​	参考链接：

​	https://www.cnblogs.com/kaleidoscope/p/9588151.html

​	https://blog.csdn.net/zhangcongyi420/article/details/86668427

​	拉链法、开放地址法、再散列法



##### 4>JDK源码里面有哪些类是用开放地址法解决哈希冲突的



##### 5>说说LinkedHashMap的底层原理



##### 6>说说HashMap在JDK1.7和JDK1.8中实现不同在哪里



##### 7>JDK1.8的HashMap的扩容机制详细说说



##### 8>为什么HashMap线程不安全

参考链接：https://blog.csdn.net/swpu_ocean/article/details/88917958

`HashMap`的线程不安全主要体现在下面两个方面：

在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况

在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况



##### 9>Spring中的Controller ，Service，Dao是不是线程安全的

参考链接：https://blog.csdn.net/sihai12345/article/details/109466107

​	Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究，线程安全问题则从单例Bean（Singleton）和原型Bean（prototype）分别进行说明

><font color=red>单例Bean（Singleton）</font>

​	对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。

​	如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身

><font color=red>原型Bean（prototype）</font>

​	对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题



##### 10>spring单例，为什么controller、service和dao确能保证线程安全？如何保证Bean的线程安全？

​	<font color=red>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理，从“有状态”和“无状态”两个方面进行分析</font>

​	实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的

​	@Controller、@Service默认配置下不是线程安全的。因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton。即系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，从而导致线程不安全

​	但是如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把 "singleton"改为’‘protopyte’ 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了

- 有状态就是有数据存储功能
- 无状态就是不会保存数据，controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的

​	还需注意static变量，虽然有些Bean定义指定了原型模式，但是对于static的变量还是无法保证100%的线程安全，因此<font color=red>Spring框架下线程是否安全在于如何去定义变量及Controller的配置</font>

> 有状态Bean(Stateful Bean) ：就是有实例变量的对象，可以保存数据，是非线程安全的
>
> 无状态Bean(Stateless Bean)：就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的

​	<font color=red>或者是通过ThreadLocal解决线程安全问题，为每个线程提供一个独立的变量副本，不同线程只操作自己线程的副本变量</font>

​	<font color=blue>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</font>

​	

##### 11>为什么Spring框架不加一些多线程同步机制来保证Bean的线程安全？





##### 12>ThreadLocal底层原理

参考链接：https://www.cnblogs.com/bangiao/p/13204983.html



##### 13>ThreadLocal如何防止内存泄漏



##### 14>那除了remove方法，还有什么方法可以避免内存泄漏



##### 15>一个接口有两个实现类，在Spring中怎么去调用到自己想调用的实现类

​	注解配置：需在相应的xxxServiceImpl加上@Service("xxx")注解自定义名称

> 方式1：
>
> @Qualifier(name=“xxx”)
>
> @Autowired

​	@Autowired注入方式是byType，当出现两个及以上的实现类，定义的时候使用@Autowired自动注入则相应报错，因此采用@Qualifier（byName方式注入）和@Autowired配合使用



> 方式2：
>
> @Resource(name="xxx")

​	@Resource 默认是按照 byName 的方式注入的， 如果通过 byName 的方式匹配不到，再按 byType 的方式去匹配



##### 16>Spring循环依赖的解决方法

​	SpringIOC容器循环依赖概念：循环依赖->循环引用。即2个或以上bean互相持有对方，最终形成闭环。

​	举例：A依赖B，B依赖C，C又依赖A。<font color=red>注意：这里不是函数的循环调用(是个死循环，除非有终结条件)，是对象相互依赖关系</font>

​	构造器的循环依赖、属性注入的循环依赖（单例）、属性注入的循环依赖（原型）

​	通过分析SpringIOC的加载流程进行调整

​	@Lazy懒加载概念处理构造器的循环依赖注入问题



##### 17>SpringBean的生命周期

参考链接：https://www.cnblogs.com/zrtqsk/p/3735273.html



##### 18>SpringBoot的启动流程

参考链接：https://www.cnblogs.com/trgl/p/7353782.html



##### 20>和@Conditional注解功能类似的注解有哪些

参考链接：https://blog.csdn.net/xcy1193068639/article/details/81491071

​	`@Conditional`条件注解是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean

> 应用说明：

<1>xxxCondition实现Condition接口，重写自定义match规则

<2>创建BeanConfig配置类，设定不同场景下的Bean注入条件，在Bean对象构造器前设定注解

```java
@Conditional({xxxCondition.class})
@Bean("xxxBean")
```

<3>编写测试方法获取初始化的类信息



> <font color=red>条件配置切换类似概念</font>

​	MyBatis的DatabaseIdProvider概念，实现不同环境配置下的SQL切换，或者是指定Oracle数据库，配置别名通过配置文件进行指定（间接实现针对同一数据源配置中不同项目版本的sql版本切换）

​	不同环境配置下需要通过指定不同的参数配置指定相应的SQL，后结合数据库调整（数据库建立视图、别名的方式来解决数据库操作层的配置问题）



##### 21>SpringAOP的实现原理

​	了解SpringAOP的基本概念，结合实际应用场景进行阐述（拦截器概念扩展）

​	借助“横向抽取”概念替换原有“纵向继承”的方式，便于程序扩展，结合反射概念阐述场景应用

​	自定义注解、自定义切面、拦截配置



##### 22>如何用cglib来实现动态代理



##### 23>手撕LinkedList，实现头插、尾插、根据索引插入、根据索引删除、toString打印





### <3>参考3

#### 一面面经

##### 1>爬楼梯 递推公式 递推缺点 

##### 2>判断两个链表是否交叉

##### 3>判断象棋里的‘马’到某个点最少走几步（广度遍历，深度遍历） 

##### 4>索引b+树 

##### 5>红黑树

##### 6>hashmap原理 

##### 7>java垃圾回收

##### 8>tcp标志位



##### 9>流量控制怎么实现



##### 10>arp协议



##### 11>进程通信方式 用过哪些?没用过



#####  12>linux常用指令

ps -ef | grep tomcat

find / -name xxx

tail -500f logs/catalina.out

./bin/start.sh   ./bin/shutdown.sh

crontable 查看定时任务配置



#####  13>进程监听了哪些端口指令



#####   14>常用哪些系统调用函数



#### 二面面经

##### 1>自我介绍 + 项目 

##### 2>线程池 

##### 3>servlet和jsp的区别？ 

##### 4>jsp会不会转为servelt执行？ 

##### 5>问concurrenthashmap？ 不会 说我只熟悉hashmap 

##### 6>hashmap底层讲讲 

##### 7>hash冲突解决方式 

##### 8>tcp三次握手能不能干掉一次？ 

##### 9>输入url发生了什么？服务端发生了什么？

> 前端参考：

<1>输入地址

<2>DNS解析，寻找服务器

<3>TCP连接，三次握手

<4>发送http请求，找到相应的资源库

<5>返回http响应

<6>浏览器解析渲染页面

<7>断开连接

> 服务端参考：

涉及Servlet相关的访问（重定向和转发概念扩展），Spring框架的渲染过程







##### 11>如何解决端口占用？

​	参考思路：先查找当前端口号被哪个进程占用，随后kill杀掉进程

> windows环境下

```
// 查看指定端口号进程
netstat -aon | findstr "80"
// 查看指定进程号的进程信息
tasklist | findstr "1688"
// 杀死指定进程
taskkill /pid 1688 /F
```



> linux环境下

```
// 查看占用指定端口号的进程
lsof -i :8083
// 杀死指定进程
kill -9 pid
```



##### 12>数据库是怎么把数据显示出来的，查询过程? 



##### 13>查找部署的web的数据库在哪里? 

​	结合日常项目开发经验进行分析

​	从打包的war中查看指定的解压项目下的项目配置文件（Springboot：WEB-INF/classes文件夹下的application系列文件）

​	考虑数据库配置的安全性和数据库的可维护性，将数据库配置放置在容器层面，随后在应用中通过指定ID进行引用



##### 14>快排思想，复杂度，最坏复杂度 



#### HR面

#####  1>自我介绍 

#####  2>说一下自己的性格，家里的情况 

#####  3>为什么不考研？ 

#####  4>对企业的了解

#####  5>投过的大厂

#####  6>拿到了哪些offer 工资多少 

#####  7>期待薪资 

#####  8>对加班的看法 

#####  9>反问 



## 2.个人面经整理

### <1>一面面经-2021.05.18

#### 面试说明

面试时间：晚上7.00，面试时长1h左右

面试说明：个人自我介绍，结合简历了解相关的技术栈和项目经历，由浅入深

#### 面试题目整理

##### 1>为什么放弃国企编制？加班情况如何？

​	结合实际情况说明，加班一般跟着项目走，有时候响应需求周末也会有上线安排



##### 2>在上家公司主要工作内容？项目亮点？最有意义的是什么？解决过什么问题？

​	进入科技部的前期主要是待在网点轮岗、跟柜，我当时的定位主要是跟着大堂经理、客户经理了解一些银行业务的运作和流程，协助他们完成一些事务性的工作

​	后续有幸进入开发部门，从一开始的项目维护，到后续接触行内开发框架、开源框架、流程引擎相关的一些应用，逐步接触行内流程管理类系统的开发，到后续数字化经营大屏展示、公共管理模块构建、互联网H5应用、总分一体化BIMS组件等开发

​	从个人的角度上来说，因为接触过许多业务流程管理开发，我觉得整个过程最有意义的不局限于业务流程的了解，而是在这个过程中对自身开发技能提升和效率优化的一些思考和总结。因此当时也是和几个同事一起构建基于Springboot+vue框架的公共管理平台概念，结合现有业务需求和开发规范抽离出相关的模块，后续子系统迭代开发均可基于公共管理平台概念进行相应的扩展迭代和维护，这个从0到1的过程是我觉得比较有意义的。

​	重点难点：行内系统开发主要是业务性趋导，行内流程开发并没有一套相对完善的基础框架，所以我们从一开始也是基于探索性的尝试，不管是技术选型、系统架构构建、系统功能设计，前期会经历比较长时间的摸索，但在这个过程中经过大家思维的碰撞才陆陆续续使开发方向走向正轨。会参考前辈的一些开发经验和框架设计的理念，也会去找开源框架以及系统设计相关的资料，再结合现有行内的开发规范和业务开发相关的内容进一步扩展迭代公共管理平台

​	

##### 3>遇到过数据量最大的表？

​	<font color=red>面试官想了解的是：结合实际情况阐述，进一步分析数据库设计思路和大数据量业务处理相关内容，但比较可惜感觉自己因为缺乏信心没能应对好这个问题</font>

​	例如数字外呼系统：具体分析

​	就外呼模块而言，管理员每周会上传2~3个任务包开启业务流程，每个任务包会根据指定任务配置自动流转到各个渠道进行处理，每个任务包数据量控制在3w~5w不等，系统会根据历史记录自动对数据进行过滤和清洗

​	数据库设计角度上拆分：除却基本的数据库设计，针对大数据量处理和后续的历史记录维护，拆分业务流程记录和数据记录、当前流程和历史流程概念，在代码设计和应用交互上也相应进行调整

​	针对大数据量查询，则考虑通过构建适当的索引和sql优化从而提高查询效率



​	进一步扩展：

​	索引概念：如何构建合适的索引，遇到什么问题？

​	sql优化：针对sql和交互优化作出了什么调整？



##### 4>团队大概有多少人？项目的组织架构？平时项目是怎么分工的？

​	我所处的团队开发人员现在有近20余人，近期也陆陆续续涌进了一些20年的新鲜血液，按照不同的业务领域划分相应的小组，有建行到家团队、RPA、行内流程管理系统开发团队、总分一体化上收等，团队间也会有工作交叉的部分，在团队协作开发系统之余，有时候应实际安排也会自己独立完成某些业务需求，所以在这个过程中会兼顾比较多的内容，也在这个过程中接触到许多不同的知识。



##### 5>微服务这块有涉及吗？平时有去了解过？

​	构建公共模块概念的时候有接触过相关的知识点，后续根据实际业务需求调整了策略，通过构建多模块工程实现系统架构整合（在这个过程中也参考建行到家体系后台相关设计），近期应总行的总分一体化上收策略，接触总行的系统架构体系，主要是参与BIMS组件应用开发，涉及P8、P2、P12的内容

​	

##### 6>在公司呆了两年，两年感觉自己有什么成长？

​	进入公司前几个月主要是跟岗业务相关，在这个过程中比较幸运的是能跟着客户经理了解到行内的一些流程系统的应用并帮忙解决一些流程上的问题，这个阶段的经验积累，也是我作为后续选择信息开发科的一个参考，使我进入科技部之后能够快速进入状态，快速融入业务流程系统开发。

​	工作之余会去接触一些新的框架和知识点。从个人的角度上来说，因为接触过许多业务流程管理开发，我觉得个人的成长最有意义的是在工作的过程中我会比较善于去复盘，会结合行内现有的流程开发和规范，去考虑如何构建一套相对完善的开发框架，也是我们当初构建公共流程管理平台的初衷，在这个摸索的过程中能够连接到各式各样的知识，提升自己对系统架构的认识和把握，这个从0到1的过程是是我认为比较有意义且能够让我快速成长。



##### 7>进一步衍生自身对系统架构（项目架构）的理解？结合实际情况简单介绍

​	<font color=red>面试官会在你描述项目架构的时候时不时结合你的描述进行一步步扩展，从而了解你自身的一个学习的深度</font>

​	

​	需求分析（需求确认、UI设计、概要设计）、逻辑架构（数据库层面的逻辑设计、物理设计）

​	系统架构（前后端架构的构建：需求分析、技术选型（应用到什么组件、框架、jar）

​	项目架构搭建（参考开源项目：renren、ruoyi）、数据交互（前后端数据交互格式确定、文档输出））

​	应用层：项目部署环境、容器的确认

​	维护层：项目上线后的维护相关



​	项目文档管理方面：使用docway进行文档管理、md输出文档、swagger-ui进行API管理

​	项目版本管理方面：使用svn进行版本管理，部分项目使用gitlab进行版本管理



​	<font color=red>例如业务需求分析这块我们是一个怎样的定位？</font>

​	业务会提供相应的需求文档和UI设计文稿，相应我们会不定时和业务开小组会议，从我们自身的开发角度确认需求的可行性和实现周期，也会结合实际业务实现提供更优解，从而扩展系统的可维护性和迭代性，和他们共同确认开发需求、完善需求文档、概要设计和UI交互相关（<font color=red>切勿一言堂！适当拆分角色定位，体现团队协作效益</font>）

​	<font color=red>项目架构搭建完成后续新需求的开发迭代是怎样的一种模式？</font>

​	针对这块我是从两个角度去分析的：一来是需求功能的整合、二来是项目开发的整合

​	针对一些比较小的需求，会结合需求的功能趋同概念去整合到某个项目中（类似建行到家体系功能需求迭代概念），通过项目迭代的方式进行需求扩展。但是行内的流程管理类系统并不局限于需求的开发和迭代，有时候是会针对某个部门、某个应用场景去开发一套管理系统，这就涉及到“子系统”扩展的概念，这块我是参考之前实习公司的做法去扩展，通过引入“租户”的概念从而扩展子系统开发

​	<font color=red>技术选型有哪方面的选型？自己在技术选型上做过哪方面的决策？</font>

​	技术选型上我会从需求的紧迫性、团队的技术栈、后续项目的维护成本等方面综合考虑，因为在工作的过程中接触过JFinal、Spring系列的开发，在业务时间我会去关注基于Springboot和其他持久层框架、前端框架、开源组件的应用开发，结合实际业务需求去求去对比框架的功能，并分析技术实现的可行性，从而快速构建出一个基本的框架原型，后续再进行迭代维护

​	<font color=red>对比jfinal、spring、springboot框架，为什么用到他们？</font>

​	JFinal 是基于 Java 语言的极速 WEB + ORM + AOP + Template Engine 框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展、Restful。在拥有Java语言所有优势的同时再拥有ruby、python、php等动态语言的开发效率！

​	jfinal基于项目维护的时候接触到的框架，后续在自身项目扩展的时候会结合以前的一些开发经验，对项目版本进行升级，优化传统项目代码的实现。例如之前看前辈的一些sql是直接嵌入到代码中实现，会造成代码的可维护性和可读性特别差，后续了解到升级后的jfinal提供的Db.template概念（类似于SSM系列用法），所以进行了相应的更新





​	spring可以集成各种框架，

​	springboot是在spring基础上xxx，简化传统spring项目集成配置

​	mybatis->mybatis-plus：基于探索性的考虑，后续

​	我觉得技术的迭代更新是日新月异的，在这个过程中可以有对比，但不该是完全的取舍概念（鄙视链），因为针对不同的项目设计场景，不同的框架能够发挥其特定的一个优势，技术的沉淀也是基于开阔者的经验，我认为在这个环境下我要做到的是要保持接收新技术的敏感度，不断开阔自身的认知，也要在这个过程中学会去总结和反思，不断优化自身的代码设计。

​	包括应业务需求衍生的“低代码平台框架”也是我最近关注的一个点





###### 架构相关参考说明

> 构架项目的系统架构设计

逻辑架构：模块划分+接口定义（统一接口规范）+领域模型

物理架构：硬件分布+软件部署+方案优化（可伸缩性、高性能、易维护性，监控）

数据架构：存储方式+数据分布

开发架构：技术选型+文件划分+编译关系（模块依赖关系）

运行架构：物理架构+数据流的控制（系统运行中的数据流向关系）



> 系统架构的实现

​	<font color=blue>需求分析、确认关键需求、概念架构设计、细化架构设计、架构验证</font>

> 针对公共模块概念，系统架构的设计思路：

<font color=red>1.结合现有行内开发的需求特性和公共的问题，确认系统需求，划分系统功能模块</font>

<font color=red>2.确认数据架构：数据库设计（物理设计、逻辑设计）</font>

​	（数据存储是构建系统的基础）

<font color=red>3.确认开发架构：技术选型（前后端框架搭建）</font>

​	后端项目构建引申：参考网络的开源项目资源（renren、ruoyi）

​	技术选型（确认后台基本架构）：springboot、mybatis-plus、shiro、swagger-ui、poi-tl、oracle，后续根据系统功能扩展去引用其他的jar（guava、hutool等）

​	项目构建：交互设计（前后端交互设计）、异常处理机制、日志相关、rbac概念，先构建基本的项目组成结构，随后根据实际的业务需求迭代功能，优化代码（前期的摸索和选择可能需要耗费一定的时间，但如果累计了一定的经验，相关的内容可以在需求功能确认的时候便可确定相应的技术选型和架构实现）

<font color=red>4.确认运行架构：项目部署环境构建</font>

​	环境配置、容器管理

​	针对子系统一些公共的jar可通过容器配置的方式进行引用，而无需每个子系统都打包，从而减少对系统资源的占用

​	护网行动：漏洞整改、版本升级~



##### 8>对于数据表的设计？有没有涉及哪些复杂的设计？举个项目的例子描述一下

<font color=red>面试官的意图在于了解你对在数据库设计方面的思路，针对特殊场景有没有设定哪些复杂的设计</font>

> <font color=blue>数据库设计思路</font>

​	确定功能模块，数据表设计结合功能模块划分，确定原始数据和实体之间的关系，通过关联表建立多对多关联（主外键概念）

​	RBAC模块（user、role、auth、user_role、role_auth）：其中可在表中对角色或者权限进行分级设计概念，用以限定不同层级的权限划分

​	

> <font color=blue>特殊业务场景分析</font>

​	参考flowable流程引引擎设计思路，涉及流程处理状态的变更：拆分流程节点、流程状态两个概念

​	考虑数据字段冗余场景（字段的派生出现）、视图应用场景、大数据量处理问题（分表存储：拆分当前流程、历史流程概念）、中间表/报表/临时表概念

​	考虑实际业务场景的扩展：例如fhyd中，接入不同的数据来源，有两种设计思路

​	方式1：企业数据fhyd_ep_info作为主表（抽离公共的字段）、引入ce_mode的概念，通过“ce_mode+指定的relate_key”指向不同表关联的测额数据（拆表存储）

​	方式2：引用JSON模板的概念，ce_mode作为区分不同测额模型的数据字段，通过创建与ce_template模板的关联，将测额的模板以json的方式存储，随后额测数据的存储则以该模板为参考进行填充（优点在于模板设计灵活，缺点在于oracle数据库暂不支持json数据的解析，在业务字段筛选上会有点难处）；或者是测额数据还是以表数据的方式插入，限定模板变更的条件以控制模板数据的填充

​	相应的ccims中针对不同的模板数据设计思路也是类似，通过构建视图的方式将多个表关联起来进行扩展，后续引入新的模板相应则调整视图结构



> <font color=blue>扩展问题</font>

​	<font color=red>项目当中引用到了外键？外键的作用是什么？创建外键的语法</font>

​	外键用于构建两个表中“一对一、一对多”的关联，外键约束的主要目的是确保数据库中数据的完整性（当对以表的数据进行操作时，和它关联的一个或者多个表的数据能够同时发生改变：考虑新增、修改、删除的操作限制）

​	（PS：当时比较疑惑的一个点是数据库层面的外键和业务逻辑层面的关联两者的概念？）

​	结合实际情况分析外键的好处和坏处，说明部分场景下使用外键、模拟外键、不使用外键的差异：

​	不使用外键牺牲了数据库中数据的一致性，能够减少数据库的负载

​	模拟外键将一部分工作移到了数据库之外，可能需要放弃一部分一致性以获得更高的可用性，以此同时也可能会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；

​	使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库（可能出现性能下降、死锁、扩展性问题（例如历史数据的迁移））；

​	<font color=red>扩展：阿里的Java编程规范：【强制】不得使用外键与级联，一切外键概念必须在应用层解决</font>

​	说明：外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度


**Oracle创建外键的语法规则：**

```sql
-- 创建表格语法:
     create table 表名(
       字段名1 字段类型(长度) 是否为空,
        字段名2 字段类型       是否为空
);

-- 增加主键
     alter table 表名 add constraint 主键名 primary key (字段名1);

-- 增加外键:
     alter table 表名
       add constraint 外键名 foreign key (字段名1)
         references 关联表 (字段名2);

-- 在建立表格时就指定主键和外键

    create table T_STU (
      STU_ID               char(5)                         not null,
       STU_NAME             varchar2(8)                     not null,
      constraint PK_T_STU primary key (STU_ID)
);


-- 主键和外键一起建立：
     create table T_SCORE (
       EXAM_SCORE           number(5,2),
       EXAM_DATE            date,
        AUTOID               number(10)                      not null,
       STU_ID               char(5),
       SUB_ID               char(3),
       constraint PK_T_SCORE primary key (AUTOID),
       constraint FK_T_SCORE_REFE foreign key (STU_ID)
        references T_STU (STU_ID)
)
```



##### 9>为什么选择springboot？技术选型基于怎样的考虑？

​	对比说明自己在探索后台框架的分析，从团队成员技术栈、框架的功能性、后续项目的可扩展性分析（参考架构说明）

​	<font color=red>springboot配置化的原理：springboot自动装配概念，底层原理</font>



##### 10>技术栈转型是否可以接受？java转go语言？

​	是否可以接收技术栈转型？有没有了解过新的技术？自身的学习能力如何？如何体现？可以稍微具体？（在工作中遇到什么问题）

​	通过哪些方式？途径？构建自己的项目？

​	参考自己的一些实习项目开发经验，从日常的开发中总结，也会参考网络的一些开源项目。首先我会给自己定一个相对明确的目标，例如系统开发功能需要达到一个怎样的目的，如何去进一步实现这个目的，后续会参考网络资源构建自己的系统架构，遇到一些不太懂的问题或者知识点再去深入探索，也会在这个过程中去总结和反思会不会有更加好的方案（例如shiro框架的一个执行流程，扩展的话会结合公司的项目需求考虑多类型登录用户登录扩展概念）

​	<font color=red>有目的性的输入、总结性的输出</font>



##### 11>Oracle、Mysql是否了解？索引概念？

​	什么场景下考虑构建索引？大数据量的话大到什么程度需要构建

​	

​	in会构建索引吗



​	如果现在需要你去使用mysql进行开发，你觉得需要掌握到什么程度才算及格？需要了解哪方面的知识点？



​	工具的基本操作，数据表逻辑和物理设计的基本概念，数据库性能优化概念？





##### 12>针对自己列的技术栈？选择自己最擅长的部分说明（具体化）？

​	AOP？AOP底层如何实现？



​	面试官cue到，希望面试者对某个技术栈不仅仅停留在应用层？应用的门槛很低，可以参考网络的案例ctrl+c\v。例如在应用的过程中有什么坑？是如何实现的？



##### 13>最近在学什么技术？具体介绍

​	反射：如何理解反射？反射可以随便用吗？有没有什么问题？



##### 14>HashMap原理（底层原理）？除了用HashMap还有使用其他集合吗？优先队列有了解过吗？



##### 15>JVM底层概念？

​	死亡问题：是在过程中没有用到就不去了解吗？

​	业余时间会去总结和扩展自己遇到的一些问题，平时的话要做的事情很多（一条龙服务，还要扩展许多事务性工作、项目管理等），真正给到开发的时间很多时候只能推到班后，一方面为了快速响应业务需求，另外一方面也会在这个过程中去思考如何提高自己的开发效率。虽然相对来说没有一个系统的了解，都是零零散散的知识点拼凑起来，在实践中去总结经验。这个也是我比较遗憾和不足的点，因此也是考虑了一段时间，才想着希望通过自己的努力去改变这个状态，去更好的平台和环境去扩展自己的技术认知、增长自己的认识。





##### 16>Mybatis?通过注解或者在xml定义标签能够拿到数据库的东西，这个过程做了什么事情？

​	个人理解：封装JDBC层和数据库连接

​	

##### 17>互联网技术？

​	redis的作用？

​	缓存概念：guava和redis的区别？



##### 18>maven的jar冲突如何解决？

​	手动检查maven依赖冲突

​	通过idea的组件：查看maven依赖树，解决冲突

​	

​	<font color=red>引入某个jar，出现冲突时语法如何处理？例如引入a.jar，a.jar中又引入了b.jar，项目中手动引入了不同版本的b.jar，如何解决冲突</font>

​	编译时、打包时，借助标签进行过滤？



##### 19>nginx的应用场景？自己有搭过nginx？

​	代理转发概念？



##### 20>zookper的作用？



##### 21>流程引擎相关？报表引擎？技术扩展？



##### 22>java的垃圾回收机制？存在内存泄露的情况吗？



##### 22>项目异常机制处理？

​	自定义异常概念，构建异常处理机制

​	如何自定义异常：异常的基本信息？（功能模块异常区分），code、msg等

​	java异常类有哪些？关系是怎样？：throwable、exception、error三者关系？出现error程序会中断吗？进程会退出吗？



##### 8>反问

想了解公司的一些信息？

JAVA相关的岗位需求和岗位职责？工作模式、工作内容

​	面试官简单介绍了深信服现有系统的一些情况：安全方面相关（toB面向企业）的平台建设，安全监测（用户流量分析），根据业务划分（监测业务组、性能优化业务组、开发业务组）不同的团队，主打语言py、go，前端vue、php后台相关的东西

​	非互联网模式，前后端分离，业务层面处理、性能瓶颈分析，平台开发，后续项目需求迭代维护，项目管理使用git、gitlab



​	行内系统有用svn进行管理、总行项目组开发使用gitlab、个人日常项目笔记相关会去使用git（gitDesktop）



对于个人技能提升有什么好的建议和意见？

日常的工作模式和培养计划？